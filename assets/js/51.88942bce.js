(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{586:function(_,v,t){"use strict";t.r(v);var s=t(6),r=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-进程与线程和协程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程与线程和协程"}},[_._v("#")]),_._v(" 1. 进程与线程和协程")]),_._v(" "),t("p",[_._v("进程：cpu分配资源的最小单位（是并发执行的程序分配和管理资源的基本单位），是一个动态概念，竞争计算机系统资源的基本单位。（电脑运行了软件美团，就是一个进程）")]),_._v(" "),t("p",[_._v("线程：cpu调度的最小单位。进程的一个执行单元，负责当前进程中程序的执行，一个进程可以运行多个线程，"),t("strong",[_._v("多个线程可共享数据。")])]),_._v(" "),t("p",[_._v("协程：比线程更加轻量级的存在。一个线程也可以拥有多个协程。")]),_._v(" "),t("p",[_._v("区别：")]),_._v(" "),t("ol",[t("li",[_._v("进程需要独立堆栈空间与数据段，开销大；线程可共享数据段，开销小")]),_._v(" "),t("li",[_._v("包含关系")]),_._v(" "),t("li",[_._v("内存分配：进程之间空间资源相互独立，线程共享所在进程的空间资源")]),_._v(" "),t("li",[_._v("执行：进程通过程序运行入口，线程依赖于应用程序")])]),_._v(" "),t("p",[_._v("使用：频繁创建和销毁，并行操作----用线程；追求稳定安全----用进程")]),_._v(" "),t("p",[_._v("多进程：操作系统运行多个程序。"),t("strong",[_._v("浏览器是多进程的（一个tab页面，就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等）")]),_._v("。")]),_._v(" "),t("p",[_._v("多线程：同一个进程运行多个任务，用于高并发，分担计算，避免主线程阻塞，但占用内存，bug不好排查。")]),_._v(" "),t("h2",{attrs:{id:"_2-js为什么是单线程的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-js为什么是单线程的"}},[_._v("#")]),_._v(" 2. js为什么是单线程的")]),_._v(" "),t("p",[_._v("js是实现用户与浏览器的交互，以及操作dom；")]),_._v(" "),t("p",[_._v("如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。")]),_._v(" "),t("h2",{attrs:{id:"_3-进程调度策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-进程调度策略"}},[_._v("#")]),_._v(" 3. 进程调度策略")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("先来先服务策略FCFS")]),_._v(" "),t("p",[_._v("可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中"),t("strong",[_._v("选择一个或多个最先进入该队列的作业")]),_._v("，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。（"),t("strong",[_._v("简单公平，有利于长作业，但不利于短作业")]),_._v("）")])]),_._v(" "),t("li",[t("p",[_._v("短作业(进程)优先调度算法")]),_._v(" "),t("p",[_._v("它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法 是从后备队列中选择一个或若干个"),t("strong",[_._v("估计运行时间最短的作业")]),_._v("，将它们调入内存运行。（"),t("strong",[_._v("降低了系统平均周转时间。\n但对长作业不利，长作业有可能长时间得不到调度。")]),_._v("）")])]),_._v(" "),t("li",[t("p",[_._v("高优先权优先调度算法")]),_._v(" "),t("p",[_._v("常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中"),t("strong",[_._v("选择若干个优先权最高的作业")]),_._v("装入内存。")])]),_._v(" "),t("li",[t("p",[_._v("高响应比优先调度算法")]),_._v(" "),t("p",[_._v("为每个作业引入前面所述的动态优 先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在 等待一定的时间后，必然有机会分配到处理机。")])]),_._v(" "),t("li",[t("p",[_._v("时间片轮转法（适用于分时系统）")]),_._v(" "),t("p",[_._v("所有的就绪进程"),t("strong",[_._v("按先来先服务的原则排成一个队列")]),_._v("，每次调度时，把CPU 分配给"),t("strong",[_._v("队首进程，并令其执行一个时间片")]),_._v("。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。")])]),_._v(" "),t("li",[t("p",[_._v("多级反馈队列调度算法（best）")]),_._v(" "),t("ul",[t("li",[_._v("提高吞吐量和缩短平均周转时间而照顾短进程；")]),_._v(" "),t("li",[_._v("为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；")]),_._v(" "),t("li",[_._v("不必事先估计进程的执行时间。")])])])]),_._v(" "),t("ul",[t("li",[t("p",[_._v("多个就绪队列，第一队列优先级最高；")])]),_._v(" "),t("li",[t("p",[_._v("赋予各个队列中进程执行时间片的大小不一样，优先级越高的队列中，多个进程的运行时间片越小；")])]),_._v(" "),t("li",[t("p",[_._v("新进程进入内存后，按FCFS原则排队等待调度。如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾。")])]),_._v(" "),t("li",[t("p",[_._v("设置多个就绪队列，并为各个队列赋予不同的优先级。各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小")])]),_._v(" "),t("li",[t("p",[_._v("仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。")])])]),_._v(" "),t("h2",{attrs:{id:"_4-线程调度策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-线程调度策略"}},[_._v("#")]),_._v(" 4. 线程调度策略")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("分时调度模式: 是指让所有的线程轮流获得cpu的使用权,并且平均"),t("strong",[_._v("分配每个线程占用的cpu的时间片")]),_._v(".")])]),_._v(" "),t("li",[t("p",[_._v("抢占式调度模式: JAVA虚拟机采用抢占式调度模式,是指优先让可运行池中"),t("strong",[_._v("优先级高的线程占用CPU")]),_._v(",如果可运行池中的线程优先级相同,那就随机选择一个线程,使其占用CPU.处于运行状态的线程会一直运行,直至它不得不放弃CPU.")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);