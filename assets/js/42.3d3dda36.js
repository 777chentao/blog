(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{577:function(_,v,t){"use strict";t.r(v);var s=t(6),e=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-websocket"}},[_._v("#")]),_._v(" 1. websocket")]),_._v(" "),t("h3",{attrs:{id:"_1-1-传输协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-传输协议"}},[_._v("#")]),_._v(" 1.1 传输协议")]),_._v(" "),t("p",[_._v("WebSocket 是基于Http 协议的改进，Http 为无状态协议，基于短连接，需要频繁的发起请求，第二 Http 只能客户端发起请求，服务端无法主动请求。")]),_._v(" "),t("p",[_._v("WebSocket 是基于TCP/IP协议，独立于HTTP协议的通信协议。")]),_._v(" "),t("p",[_._v("WebSocket 是双向通讯，有状态，客户端一（多）个与服务端一（多）双向实时响应")]),_._v(" "),t("p",[_._v("WebSocket 是应用在浏览器的 Socket （是 Socket 模型接口的实现），Socket 是一个网络通信接口 （通信规范）")]),_._v(" "),t("p",[_._v("WebSocket协议端口是80")]),_._v(" "),t("p",[_._v("WebSocket SSL协议端口是443")]),_._v(" "),t("p",[t("em",[t("strong",[_._v("WebSocket协议不受同源策略影响。")])])]),_._v(" "),t("h3",{attrs:{id:"_1-2-wss和ws"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-wss和ws"}},[_._v("#")]),_._v(" 1.2 wss和ws")]),_._v(" "),t("p",[_._v("加密过程：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("客户端发起一个https的请求，把自身支持的一系列密钥算法发送给服务端")])]),_._v(" "),t("li",[t("p",[_._v("服务端选出一种加密算法和HASH算法，以证书的形式返回给客户端。")])]),_._v(" "),t("li",[t("p",[_._v("客户端收到服务端响应的证书后，浏览器会生成一串随机密码，然后用证书中的公钥加密。把用 "),t("code",[_._v("随机数密码")]),_._v("加密 “握手消息+握手消息HASH值(签名)”和用公钥加密的随机密码 一起发送给服务端")])]),_._v(" "),t("li",[t("p",[_._v("服务端拿到客户端传来的密文，用自己的私钥来解密，获取随机密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。")])])]),_._v(" "),t("h3",{attrs:{id:"_1-3-何时断开"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-何时断开"}},[_._v("#")]),_._v(" 1.3 何时断开")]),_._v(" "),t("p",[_._v("当刷新页面时，WebSocket 连接会被断开。这是因为刷新页面会重新加载整个页面，包括关闭所有正在运行的 WebSocket 连接，可在页面的 onload 事件中重新建立连接。")]),_._v(" "),t("p",[_._v("另外，有些浏览器可能会在刷新页面时缓存 WebSocket 连接，以便在页面加载完成后快速重新建立连接。但是，这可能取决于浏览器的版本和设置。")]),_._v(" "),t("p",[_._v("离开页面websocket就会自动断开=》在组件销毁时断开（在vue destroy生命周期里面调用 websock.close() 手动关闭）、路由切换时断开（ this.$router.afterEach）")]),_._v(" "),t("h3",{attrs:{id:"_1-4-断线重连和心跳机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-断线重连和心跳机制"}},[_._v("#")]),_._v(" 1.4 断线重连和心跳机制")]),_._v(" "),t("p",[_._v("心跳机制：在客户端连接成功的回调onopen中即开启心跳。心跳处理函数内部使用定时器延时触发向服务端发送消息的方法，待服务器将消息返回证明是连线成功状态下，继续调用心跳检测方法。")]),_._v(" "),t("p",[_._v("断线重连：若某时间段内客户端发送了消息，而服务端未返回，则认定为断线；这个时候会触发到websocket中的onclose事件，需要重新连接服务（每隔一段时间重新new一个websoket实例的过程）")]),_._v(" "),t("h3",{attrs:{id:"_1-5-websocket一对一匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-websocket一对一匹配"}},[_._v("#")]),_._v(" 1.5 websocket一对一匹配")]),_._v(" "),t("p",[_._v("在WebSocket传递消息的"),t("strong",[_._v("Session中有SessionId")]),_._v("可以作为客户端标识，但是并不太适合业务的自定义需求，所以客户端传参需要先定义客户端唯一标识UID，先将"),t("strong",[_._v("UID使用时间戳生成")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"_2-快速排序详细"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-快速排序详细"}},[_._v("#")]),_._v(" 2. 快速排序详细")]),_._v(" "),t("h3",{attrs:{id:"_2-1-稳定不稳定-平均nlogn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-稳定不稳定-平均nlogn"}},[_._v("#")]),_._v(" 2.1 稳定不稳定（平均nlogn）")]),_._v(" "),t("p",[_._v("快速排序的性能高度依赖于你"),t("strong",[_._v("选择的基准值")]),_._v("。")]),_._v(" "),t("p",[_._v("最坏为O（n2）：第一个元素用作基准值，且要处理的数组是有序的")]),_._v(" "),t("p",[_._v("最好为O（nlogn）：调用栈的高度为O(log n)，整个算法需要的时间为O(nlog n)")]),_._v(" "),t("p",[_._v("平均为O（nlogn）")]),_._v(" "),t("h3",{attrs:{id:"_2-2-快速排序一般优于归并排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-快速排序一般优于归并排序"}},[_._v("#")]),_._v(" 2.2 快速排序一般优于归并排序")]),_._v(" "),t("p",[_._v("归并排序和快速排序的时间复杂度都是 O(nlogn)，但是通常比其他排序算法快得多，"),t("strong",[_._v("因为它在原地运行，而不需要创建任何辅助数组来保存临时值")]),_._v("。分配和释放辅助数组所需的时间是显而易见的。")]),_._v(" "),t("p",[_._v("但是在链表时，快速排序在链接列表中仍然非常快。合并排序（链表算法不需要任何额外的辅助存储空间）往往更快，因为它更均匀地将列表分成两半，并且每次执行合并所做的工作比执行分区步骤所做的工作更少。")]),_._v(" "),t("h2",{attrs:{id:"_3-200亿大小的数组选取最大100个数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-200亿大小的数组选取最大100个数"}},[_._v("#")]),_._v(" 3. 200亿大小的数组选取最大100个数")]),_._v(" "),t("h3",{attrs:{id:"_3-1-top-k-分治-小顶堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-top-k-分治-小顶堆"}},[_._v("#")]),_._v(" 3.1 Top K（分治+小顶堆）")]),_._v(" "),t("p",[_._v("在海量乱序数据中找到前K个数据。例如在海量搜索结果中找到权重最高的前K个结果。")]),_._v(" "),t("p",[_._v("问题：在10亿行浮点数的文件中找到最大的前100个数字。")]),_._v(" "),t("p",[t("strong",[_._v("思路一：直接排序")])]),_._v(" "),t("p",[_._v("将数据全部排序后取最后100个数。")]),_._v(" "),t("p",[_._v("时间复杂度O（nlogn），空间复杂度10亿*4字节==4GB，需要将数据全部加载到内存中。")]),_._v(" "),t("p",[t("strong",[_._v("思路二：局部淘汰法")])]),_._v(" "),t("p",[_._v("使用一个数组存储文件前100个浮点数，并排好序，记为序列L。遍历文件中剩余的数字，如果比序列L中最小值还要小则直接丢弃，否则通过插入排序的方式插入序列L并删掉最小数，最终得到的序列L就是前100大的数。")]),_._v(" "),t("p",[_._v("时间复杂度O（n），空间复杂度O（100）")]),_._v(" "),t("p",[t("strong",[_._v("思路三：快速排序")])]),_._v(" "),t("p",[_._v("以数组最后一个元素作为基准值，不断排序。计算"),t("code",[_._v("[mid, right]")]),_._v("数组长度L")]),_._v(" "),t("p",[_._v("时间复杂度O（nlogn），空间复杂度10亿=》4gb")]),_._v(" "),t("p",[t("strong",[_._v("思路四：分治法")])]),_._v(" "),t("p",[_._v("将数据分散成多份，通过多台机器分布式运算或者多线程并发计算的方式取得每份数据的Top K，然后汇总结果。")]),_._v(" "),t("p",[_._v("可以解决快速排序等思路中对计算机内存要求较大的问题。")]),_._v(" "),t("p",[t("strong",[_._v("思路五：小顶堆")])]),_._v(" "),t("p",[_._v("取文件中前K个数在内存中维护一个长度为K的小顶堆，然后从文件中挨个读取数字并和堆顶比较，如果比堆顶小则直接丢弃，否则替换堆顶后调整小顶堆。遍历完文件中所有的数字后，小顶堆中的K个数就是所求的Top K。只需要遍历一次文件中的数字，不存在多次读写数据的问题。")]),_._v(" "),t("p",[_._v("时间复杂度，最好情况下文件中前K个数就是Top K，遍历一遍文件即可，时间复杂度为 O（n） ；最坏情况下遍历文件中每个数都需要调整小顶堆，时间复杂度为O（nlogk）。空间复杂度：只需要在内存中维护小顶堆，空间复杂度为 O（100）")]),_._v(" "),t("p",[t("strong",[_._v("思路六：并行计算（多线程或者分布式运算）")])]),_._v(" "),t("p",[_._v("划分为m份并行执行以下操作：")]),_._v(" "),t("p",[_._v("每份使用小顶堆法选出最大的100个数")]),_._v(" "),t("p",[_._v("二分法查找m个100的数")]),_._v(" "),t("p",[t("strong",[_._v("实际情况：")])]),_._v(" "),t("ul",[t("li",[_._v("是否并发：并发可以显著提高运行速度，单机多核可以使用Hash将数据划分为多份子数据然后多线程并发排序，多机可以使用Hash+Socket方法将数据分发到多台机器上")]),_._v(" "),t("li",[_._v("是否有足够内存：如果机器内存足够可以直接在内存中处理即可，如果机器内存不足可以将原始文件切分成多个小文件")])]),_._v(" "),t("h3",{attrs:{id:"_3-2-出现次数最多的k个数字"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-出现次数最多的k个数字"}},[_._v("#")]),_._v(" 3.2 出现次数最多的k个数字")]),_._v(" "),t("p",[_._v("用hash树记录每个数字出现的频率，转化为在各个数字的频率中找到Top K的问题。")]),_._v(" "),t("h3",{attrs:{id:"_3-3-第k个数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-第k个数"}},[_._v("#")]),_._v(" 3.3 第k个数")]),_._v(" "),t("p",[_._v("快速排序+判断左右数组长度来确定")]),_._v(" "),t("p",[_._v("桶排序")]),_._v(" "),t("p",[_._v("多路并归排序")])])}),[],!1,null,null,null);v.default=e.exports}}]);